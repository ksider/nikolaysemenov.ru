<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Интерактивная карта пластиков</title>
  <style>

  :root {
    --canvas: #050b18;
    --surface: rgba(15, 23, 42, 0.84);
    --surface-strong: rgba(15, 23, 42, 0.92);
    --border: rgba(94, 108, 132, 0.38);
    --border-strong: rgba(94, 108, 132, 0.65);
    --accent: #38bdf8;
    --accent-strong: #0ea5e9;
    --muted: #94a3b8;
    --text-primary: #e2e8f0;
    --text-secondary: rgba(226, 232, 240, 0.72);
    --success: #34d399;
    --danger: #fb7185;
  }

  * {
    box-sizing: border-box;
  }

  html,
  body {
    height: 100%;
  }

  body {
    margin: 0;
    font-family: "Inter", "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    background:
      radial-gradient(circle at 18% 15%, rgba(14, 165, 233, 0.18), transparent 60%),
      radial-gradient(circle at 78% 12%, rgba(34, 197, 94, 0.14), transparent 58%),
      radial-gradient(circle at 10% 85%, rgba(56, 189, 248, 0.12), transparent 60%),
      linear-gradient(180deg, #020617 0%, #0b1120 45%, #111827 100%);
    color: var(--text-primary);
    overflow: hidden;
  }

  .map-shell {
    position: relative;
    width: 100%;
    height: 100%;
  }

  .floating-panel {
    position: absolute;
    display: grid;
    gap: 16px;
    padding: 20px 22px;
    background: rgba(11, 20, 36, 0.78);
    border: 1px solid rgba(148, 163, 184, 0.24);
    border-radius: 20px;
    box-shadow: 0 24px 60px rgba(2, 6, 23, 0.48);
    backdrop-filter: blur(14px);
    z-index: 20;
  }

  .panel-controls {
    top: 28px;
    left: 28px;
    max-width: 420px;
    color: var(--text-secondary);
    display: grid;
    gap: 18px;
    align-content: start;
  }

  .panel-controls h1 {
    margin: 0;
    font-size: clamp(1.6rem, 3vw, 2.3rem);
    line-height: 1.15;
    color: var(--text-primary);
  }

  .panel-controls p {
    margin: 6px 0 0;
    line-height: 1.55;
  }

  .control-actions {
    display: grid;
    gap: 14px;
  }

  .control-links {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }

  .control-link {
    color: rgba(148, 163, 184, 0.9);
    font-size: 0.88rem;
    font-weight: 600;
    text-decoration: none;
    padding: 6px 10px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.24);
    background: rgba(15, 23, 42, 0.55);
    transition: color 0.2s ease, border-color 0.2s ease, background 0.2s ease, transform 0.2s ease;
  }

  .control-link:hover,
  .control-link:focus-visible {
    color: #38bdf8;
    border-color: rgba(56, 189, 248, 0.45);
    background: rgba(14, 165, 233, 0.16);
    transform: translateY(-1px);
    outline: none;
  }

  .lang-switcher {
    display: inline-flex;
    gap: 6px;
    padding: 6px;
    border-radius: 999px;
    border: 1px solid rgba(148, 163, 184, 0.4);
    background: rgba(15, 23, 42, 0.7);
    box-shadow: 0 18px 36px rgba(2, 6, 23, 0.4);
  }

  .lang-button {
    border: none;
    background: transparent;
    color: var(--text-secondary);
    font-weight: 600;
    font-size: 0.95rem;
    padding: 6px 16px;
    border-radius: 999px;
    cursor: pointer;
    transition: background 0.18s ease, color 0.18s ease;
  }

  .lang-button.active {
    background: rgba(56, 189, 248, 0.22);
    color: var(--text-primary);
    box-shadow: inset 0 0 0 1px rgba(56, 189, 248, 0.4);
  }

  .lang-button:focus-visible {
    outline: 2px solid var(--accent);
    outline-offset: 2px;
  }

  .action-buttons {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
  }

  .pill-button {
    padding: 10px 22px;
    border-radius: 999px;
    font-size: 0.95rem;
    font-weight: 600;
    background: transparent;
    border: 1px solid var(--border);
    color: var(--text-primary);
    cursor: pointer;
    transition: transform 0.2s ease, background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
  }

  .pill-button:disabled {
    opacity: 0.45;
    cursor: not-allowed;
  }

  .pill-button.ghost:hover:not(:disabled) {
    background: rgba(148, 163, 184, 0.12);
    border-color: var(--border-strong);
    transform: translateY(-1px);
  }

  .pill-button.accent {
    border: 1px solid rgba(56, 189, 248, 0.45);
    background: rgba(56, 189, 248, 0.16);
    color: var(--accent);
    box-shadow: inset 0 0 0 1px rgba(56, 189, 248, 0.15);
  }

  .pill-button.accent:hover:not(:disabled) {
    background: rgba(56, 189, 248, 0.22);
    box-shadow: 0 16px 28px rgba(14, 165, 233, 0.2);
    transform: translateY(-1px);
  }

  .panel-progress {
    top: 28px;
    left: 50%;
    transform: translateX(-50%);
    min-width: 260px;
    justify-items: center;
    padding: 16px 22px;
  }

  .progress-track {
    display: flex;
    flex-wrap: wrap;
    justify-content: center;
    align-items: center;
    gap: 10px;
  }

  .progress-node {
    display: grid;
    place-items: center;
    width: 32px;
    height: 32px;
    border-radius: 50%;
    border: 1px solid var(--border);
    background: rgba(15, 23, 42, 0.8);
    color: var(--muted);
    font-size: 0.82rem;
    font-weight: 600;
  }

  .progress-node.is-current {
    border-color: var(--accent);
    color: var(--accent);
    background: rgba(56, 189, 248, 0.2);
    transform: scale(1.08);
  }

  .progress-node.is-complete {
    border-color: rgba(34, 197, 94, 0.52);
    color: var(--success);
    background: rgba(34, 197, 94, 0.18);
  }

  .progress-node.is-result {
    border-color: rgba(56, 189, 248, 0.55);
    color: #f8fafc;
    background: rgba(56, 189, 248, 0.25);
  }

  .progress-label {
    font-size: 0.9rem;
    color: var(--text-secondary);
    letter-spacing: 0.08em;
    text-transform: uppercase;
  }

  .panel-title {
    margin: 0;
    font-size: 1rem;
    letter-spacing: 0.08em;
    text-transform: uppercase;
    color: rgba(148, 163, 184, 0.95);
  }

  .panel-subtitle {
    margin: 0;
    font-size: 0.92rem;
    color: var(--text-secondary);
    line-height: 1.55;
  }

  .panel-placeholder {
    margin: 0;
    font-size: 0.9rem;
    font-style: italic;
    color: var(--muted);
  }

  .panel-history {
    margin: 0;
    padding-left: 18px;
    display: grid;
    gap: 14px;
    color: var(--text-secondary);
  }

  .panel-history-item {
    display: grid;
    gap: 6px;
  }

  .history-question {
    font-size: 0.9rem;
    line-height: 1.5;
  }

  .history-answer {
    font-size: 0.92rem;
    color: var(--accent);
    font-weight: 600;
  }

  .material-card {
    border: 1px solid rgba(56, 189, 248, 0.38);
    background: #0b1f33;
    border-radius: 18px;
    padding: 18px 20px;
    display: grid;
    gap: 8px;
  }

  .material-card h3 {
    margin: 0;
    font-size: 1rem;
    color: var(--text-primary);
  }

  .material-choice-list {
    display: grid;
    gap: 12px;
    margin-top: 12px;
  }

  .material-choice {
    border: 1px solid rgba(56, 189, 248, 0.32);
    background: rgba(8, 47, 73, 0.42);
    border-radius: 18px;
    padding: 16px 18px;
    color: var(--text-primary);
    display: grid;
    gap: 8px;
    text-align: left;
    cursor: pointer;
    transition: border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease, transform 0.2s ease;
  }

  .material-choice:hover,
  .material-choice:focus-visible {
    border-color: rgba(56, 189, 248, 0.6);
    background: rgba(14, 165, 233, 0.18);
    box-shadow: 0 18px 30px rgba(14, 165, 233, 0.22);
    transform: translateY(-1px);
    outline: none;
  }

  .material-choice.is-active {
    border-color: rgba(56, 189, 248, 0.75);
    background: rgba(14, 165, 233, 0.24);
    box-shadow: 0 20px 34px rgba(14, 165, 233, 0.28);
  }

  .material-choice .material-name {
    font-size: 1.02rem;
    font-weight: 600;
    letter-spacing: 0.01em;
  }

  .material-choice .material-hint {
    font-size: 0.9rem;
    color: rgba(148, 163, 184, 0.86);
  }

  .material-props {
    display: grid;
    gap: 6px;
  }

  .material-props p {
    margin: 0;
    font-size: 0.86rem;
    color: var(--text-secondary);
    line-height: 1.5;
  }

  .material-props span {
    color: var(--text-primary);
    font-weight: 600;
  }

  .route-console {
    position: relative;
    width: 100%;
    max-height: 220px;
    overflow-y: auto;
    padding: 16px 18px 18px;
    background: rgba(2, 6, 23, 0.78);
    border: none;
    border-radius: 14px;
    box-shadow: inset 0 0 0 1px rgba(56, 189, 248, 0.08);
    font-family: 'Fira Code', 'SFMono-Regular', Menlo, Monaco, Consolas, monospace;
    color: #38bdf8;
  }

  .route-console::-webkit-scrollbar {
    height: 6px;
  }

  .route-console::-webkit-scrollbar-thumb {
    background: rgba(56, 189, 248, 0.35);
    border-radius: 999px;
  }

  .route-console[data-empty="true"] {
    color: rgba(148, 163, 184, 0.65);
  }

  .route-line {
    display: flex;
    align-items: flex-start;
    gap: 12px;
    padding: 4px 0;
    font-size: 0.9rem;
    line-height: 1.5;
    color: inherit;
  }

  .route-line.route-header {
    text-transform: uppercase;
    letter-spacing: 0.12em;
    color: rgba(226, 232, 240, 0.75);
    font-size: 0.82rem;
  }

  .route-line.route-placeholder {
    font-style: italic;
  }

  .route-line.route-answer {
    color: #22d3ee;
  }

  .route-line .prompt {
    color: rgba(94, 234, 212, 0.9);
    flex: 0 0 auto;
  }

  .route-line.is-current {
    color: #f8fafc;
  }

  .route-line.is-current .prompt {
    color: #38bdf8;
  }

  .route-line .content {
    flex: 1 1 auto;
    color: inherit;
  }

  .map-space {
    position: absolute;
    inset: 0;
    overflow: hidden;
    cursor: grab;
    touch-action: none;
    z-index: 10;
  }

  .map-space.is-dragging {
    cursor: grabbing;
  }

  .map-pan {
    position: absolute;
    inset: 0;
    transform: translate3d(var(--pan-x, 0px), var(--pan-y, 0px), 0);
    transition: transform 0.25s ease;
    will-change: transform;
  }

  .map-pan.is-dragging {
    transition: none;
  }

  .map-canvas {
    position: absolute;
    width: 4200px;
    height: 4200px;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%) scale(var(--map-scale, 1));
    transform-origin: center;
    transition: none;
    will-change: transform;
  }

  .map-links {
    position: absolute;
    inset: 0;
    pointer-events: none;
  }

  .node-layer {
    position: absolute;
    inset: 0;
  }

  .flow-step {
    position: absolute;
    width: 320px;
    max-width: 320px;
    padding: 22px 22px 24px;
    border-radius: 22px;
    border: 1px solid rgba(148, 163, 184, 0.35);
    background: var(--surface);
    box-shadow: 0 26px 60px rgba(2, 6, 23, 0.5);
    display: grid;
    gap: 18px;
  }

  .flow-step[data-status="current"] {
    border-color: var(--accent);
    box-shadow: 0 32px 70px rgba(14, 165, 233, 0.26);
    background: #0f1b2e;
  }

  .flow-step[data-status="complete"] {
    background: var(--surface-strong);
  }

  .flow-step[data-type="result"] {
    border-color: rgba(56, 189, 248, 0.6);
    background: #0f1b2e;
    box-shadow: 0 32px 70px rgba(14, 165, 233, 0.24);
  }

  .step-header {
    display: flex;
    align-items: center;
    gap: 16px;
  }

  .step-index {
    width: 42px;
    height: 42px;
    border-radius: 50%;
    background: rgba(56, 189, 248, 0.2);
    color: var(--accent);
    display: grid;
    place-items: center;
    font-weight: 700;
    font-size: 1rem;
    letter-spacing: 0.04em;
  }

  .step-title {
    margin: 0;
    font-size: 1.05rem;
    letter-spacing: 0.01em;
    color: var(--text-primary);
  }

  .step-body {
    display: grid;
    gap: 16px;
  }

  .step-question {
    margin: 0;
    font-size: 0.98rem;
    line-height: 1.55;
    color: var(--text-primary);
  }

  .step-description {
    margin: 0;
    font-size: 0.88rem;
    color: var(--muted);
    line-height: 1.5;
  }

  .step-emphasis {
    margin: 0;
    font-size: 1.02rem;
    font-weight: 600;
    color: var(--text-primary);
  }

  .option-list {
    display: grid;
    gap: 12px;
  }

  .option-node {
    position: relative;
    text-align: left;
    border: 1px solid rgba(148, 163, 184, 0.45);
    background: rgba(15, 23, 42, 0.78);
    color: var(--text-primary);
    border-radius: 18px;
    padding: 16px 18px 16px 42px;
    font-size: 0.96rem;
    font-weight: 600;
    cursor: pointer;
    transition: transform 0.2s ease, border-color 0.2s ease, background 0.2s ease, box-shadow 0.2s ease;
  }

  .option-node::before {
    content: '';
    position: absolute;
    left: 18px;
    top: 50%;
    transform: translateY(-50%);
    width: 12px;
    height: 12px;
    border-radius: 50%;
    background: rgba(148, 163, 184, 0.5);
    box-shadow: 0 0 0 2px rgba(15, 23, 42, 0.85);
  }

  .option-node:hover {
    transform: translateY(-2px);
    border-color: var(--accent);
    background: rgba(56, 189, 248, 0.22);
    box-shadow: 0 18px 28px rgba(14, 165, 233, 0.2);
  }

  .option-node .option-note {
    display: block;
    margin-top: 6px;
    font-size: 0.8rem;
    font-weight: 500;
    color: var(--muted);
  }

  .option-node.is-selected {
    border-color: rgba(56, 189, 248, 0.6);
    background: rgba(56, 189, 248, 0.24);
  }

  .option-node.is-selected::before {
    background: var(--accent);
    box-shadow: 0 0 0 2px rgba(14, 165, 233, 0.25);
  }

  .option-node.is-selected::after {
    content: '✓';
    position: absolute;
    right: 14px;
    top: 12px;
    font-size: 0.8rem;
    color: var(--accent);
  }

  .option-node.is-faded {
    opacity: 0.35;
    pointer-events: auto;
  }

  .result-badge {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    padding: 6px 14px;
    border-radius: 999px;
    border: 1px solid rgba(56, 189, 248, 0.45);
    background: rgba(56, 189, 248, 0.22);
    color: #f8fafc;
    font-size: 0.76rem;
    letter-spacing: 0.1em;
    text-transform: uppercase;
  }

  @media (max-width: 1024px) {
    .panel-controls {
      left: 20px;
      right: 20px;
      max-width: none;
    }

    .panel-progress {
      top: auto;
      bottom: 24px;
      left: 20px;
      transform: none;
    }


  }

  @media (max-width: 768px) {
    .panel-controls {
      top: 18px;
      left: 18px;
      right: 18px;
    }

    .panel-progress {
      left: 50%;
      bottom: auto;
      top: 18px;
      transform: translateX(-50%);
    }

  }

  @media (max-width: 540px) {
    .action-buttons {
      width: 100%;
      justify-content: flex-start;
    }

    .pill-button {
      flex: 1 1 auto;
      text-align: center;
    }

    .panel-progress {
      width: calc(100% - 36px);
    }
  }
  </style>
</head>
<body>
  <div class="map-shell">
    <div class="floating-panel panel-controls">
      <div>
        <h1 id="headline"></h1>
        <p id="lead"></p>
      </div>
      <div class="control-actions">
        <div class="lang-switcher" role="group" aria-label="Language selector">
          <button type="button" class="lang-button" data-lang="ru">Русский</button>
          <button type="button" class="lang-button" data-lang="en">English</button>
        </div>
        <div class="action-buttons">
          <button type="button" class="pill-button ghost" id="backButton">Назад</button>
          <button type="button" class="pill-button accent" id="resetButton">Начать заново</button>
        </div>
      </div>
      <div class="control-links">
        <a class="control-link" id="classicLink" href="classic.html">Упрощённая версия</a>
        <a class="control-link" id="sourceLink" href="https://www.canada.ca/en/conservation-institute/services/conservation-preservation-publications/cci-notes/plastics.html" target="_blank" rel="noopener noreferrer">Оригинальный флоучарт CCI</a>
      </div>
      <div class="route-console" id="historySection"></div>
    </div>
    <div class="floating-panel panel-progress">
      <div class="progress-track" id="progressTrack"></div>
      <span class="progress-label" id="progressLabel"></span>
    </div>
    <div class="map-space" id="mapSpace">
      <div class="map-pan" id="mapPan">
        <div class="map-canvas" id="mapCanvas">
          <svg class="map-links" id="mapLinks" width="4200" height="4200" viewBox="0 0 4200 4200"></svg>
          <div class="node-layer" id="flowTrack"></div>
        </div>
      </div>
    </div>
  </div>
  <script>
const uiText = {
      pageTitle: {
        ru: 'Интерактивная идентификация пластиков',
        en: 'Interactive Plastic Identification'
      },
      heading: {
        ru: 'Интерактивная идентификация пластиков',
        en: 'Interactive Plastic Identification'
      },
      lead: {
        ru: 'Следуйте шагам блок-схемы: отвечайте на вопросы и сравнивайте наблюдения, чтобы сузить круг подходящих материалов. В любой момент можно вернуться на шаг назад или начать заново.',
        en: 'Follow the flowchart: answer the questions and compare your observations to narrow down possible plastics. You can step back or restart at any moment.'
      },
      classicLink: {
        ru: 'Упрощённая версия',
        en: 'Simplified flowchart'
      },
      sourceLink: {
        ru: 'Оригинальный флоучарт CCI',
        en: 'Original CCI flowchart'
      },
      historyHeading: {
        ru: 'Пройденный путь',
        en: 'Path Taken'
      },
      historyPlaceholder: {
        ru: 'Ответы появятся после выбора первого варианта.',
        en: 'Your answers will appear after you make the first choice.'
      },
      back: {
        ru: 'Назад',
        en: 'Back'
      },
      reset: {
        ru: 'Начать заново',
        en: 'Start over'
      },
      answerLabel: {
        ru: 'Ответ:',
        en: 'Answer:'
      },
      errorLoading: {
        ru: 'Не удалось загрузить следующий шаг.',
        en: 'Failed to load the next step.'
      },
      languageSwitcher: {
        ru: 'Переключатель языка',
        en: 'Language selector'
      }
    };

const flow = {
      start: {
        type: 'question',
        title: {
          ru: 'Пластиковый материал',
          en: 'Plastic Material'
        },
        text: {
          ru: 'Прижмите к образцу нагретый металлический наконечник. Размягчается ли материал?',
          en: 'Press a heated metal tip against the sample. Does the material soften?'
        },
        options: [
          {
            label: {
              ru: 'Да, размягчается',
              en: 'Yes, it softens'
            },
            note: {
              ru: 'Термопласт',
              en: 'Thermoplastic'
            },
            next: 'thermoplastic_water'
          },
          {
            label: {
              ru: 'Нет, не размягчается',
              en: 'No, it does not soften'
            },
            note: {
              ru: 'Термореактивный пластик',
              en: 'Thermosetting plastic'
            },
            next: 'thermoset_burn'
          }
        ]
      },
      thermoplastic_water: {
        type: 'question',
        title: {
          ru: 'Термопласт',
          en: 'Thermoplastic'
        },
        text: {
          ru: 'Бросьте маленький образец в воду. Он плавает или тонет?',
          en: 'Drop a small sample into water. Does it float or sink?'
        },
        description: {
          ru: 'Этот шаг разделяет полиолефины (обычно легче воды) и остальные термопласты.',
          en: 'This separates lighter-than-water polyolefins from other thermoplastics.'
        },
        options: [
          {
            label: {
              ru: 'Плавает',
              en: 'Floats'
            },
            note: {
              ru: 'Полиолефины',
              en: 'Polyolefins'
            },
            next: 'polyolefins_smell'
          },
          {
            label: {
              ru: 'Тонет',
              en: 'Sinks'
            },
            note: {
              ru: 'Другие термопласты',
              en: 'All other thermoplastics'
            },
            next: 'thermoplastic_burn_flame'
          }
        ]
      },
      polyolefins_smell: {
        type: 'question',
        title: {
          ru: 'Полиолефины',
          en: 'Polyolefins'
        },
        text: {
          ru: 'При сжигании небольшого образца какой запах вы ощущаете?',
          en: 'When burning a small sample, what odour do you notice?'
        },
        description: {
          ru: 'Полиэтилен, полипропилен и TPX дают схожее пламя, поэтому запах и внешний вид образца помогают их отличить.',
          en: 'Polyethylene, polypropylene, and TPX show similar flames, so odour and specimen appearance help tell them apart.'
        },
        options: [
          {
            label: {
              ru: 'Парафин, тёплый запах свечи',
              en: 'Paraffin, warm candle smell'
            },
            next: 'pe'
          },
          {
            label: {
              ru: 'Едкий, похож на дизельное топливо',
              en: 'Acrid, like diesel fumes'
            },
            next: 'pp'
          },
          {
            label: {
              ru: 'Запаха почти нет, образец абсолютно прозрачный',
              en: 'Hardly any smell, sample is completely clear'
            },
            next: 'tpx'
          }
        ]
      },
      pe: {
        type: 'result',
        title: {
          ru: 'Полиэтилен (PE)',
          en: 'Polyethylene (PE)'
        },
        description: {
          ru: 'Типичный представитель плавающих полиолефинов.',
          en: 'Representative of floating polyolefins.'
        },
        materials: [
          {
            name: {
              ru: 'Полиэтилен (PE)',
              en: 'Polyethylene (PE)'
            },
            flame: {
              ru: 'Синее пламя с жёлтым кончиком',
              en: 'Blue flame with yellow tip'
            },
            odour: {
              ru: 'Парафин, свеча',
              en: 'Paraffin, candle-like'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Легко царапается ногтем',
              en: 'Scratches easily with a fingernail'
            }
          }
        ]
      },
      pp: {
        type: 'result',
        title: {
          ru: 'Полипропилен (PP)',
          en: 'Polypropylene (PP)'
        },
        description: {
          ru: 'Плотность чуть меньше единицы, поэтому образец плавает.',
          en: 'Density is slightly below water, so the sample floats.'
        },
        materials: [
          {
            name: {
              ru: 'Полипропилен (PP)',
              en: 'Polypropylene (PP)'
            },
            flame: {
              ru: 'Синее пламя с жёлтым кончиком',
              en: 'Blue flame with yellow tip'
            },
            odour: {
              ru: 'Едкий, дизельный',
              en: 'Acrid, diesel-like'
            },
            speed: {
              ru: 'Медленно',
              en: 'Slow'
            },
            other: {
              ru: 'Не царапается ногтем',
              en: 'Does not scratch with a fingernail'
            }
          }
        ]
      },
      tpx: {
        type: 'result',
        title: {
          ru: 'Полиметилпентен (TPX)',
          en: 'Polymethylpentene (TPX)'
        },
        description: {
          ru: 'Прозрачный полиолефин с очень низкой плотностью.',
          en: 'Transparent polyolefin with very low density.'
        },
        materials: [
          {
            name: {
              ru: 'Polymethylpentene (TPX)',
              en: 'Polymethylpentene (TPX)'
            },
            flame: {
              ru: 'Синее пламя',
              en: 'Blue flame'
            },
            odour: {
              ru: 'Практически отсутствует',
              en: 'Almost odourless'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Прозрачный «стеклянный» вид',
              en: 'Crystal-clear “glassy” appearance'
            }
          }
        ]
      },
      thermoplastic_burn_flame: {
        type: 'question',
        title: {
          ru: 'Другие термопласты',
          en: 'Other Thermoplastics'
        },
        text: {
          ru: 'При поджигании образца появляется пламя?',
          en: 'Does the sample produce a flame when ignited?'
        },
        description: {
          ru: 'Наблюдение за пламенем помогает отделить фторполимеры от остальных материалов.',
          en: 'Flame behaviour separates fluoropolymers from other materials.'
        },
        options: [
          {
            label: {
              ru: 'Нет, пламени нет',
              en: 'No flame appears'
            },
            next: 'no_flames_drips'
          },
          {
            label: {
              ru: 'Да, пламя есть',
              en: 'Yes, a flame appears'
            },
            next: 'flame_present'
          }
        ]
      },
      no_flames_drips: {
        type: 'question',
        title: {
          ru: 'Без пламени',
          en: 'No Flame'
        },
        text: {
          ru: 'Материал плавится и образует мягкие капли или нити?',
          en: 'Does the material melt and form soft drips or strings?'
        },
        description: {
          ru: 'Даже если пламени нет, поведение расплава подсказывает, какой именно фторполимер перед вами.',
          en: 'Even without a flame, melt behaviour hints at the specific fluoropolymer.'
        },
        options: [
          {
            label: {
              ru: 'Да, образуются капли или нити',
              en: 'Yes, drips or strings form'
            },
            next: 'ctfe'
          },
          {
            label: {
              ru: 'Нет, материал почти не меняет форму',
              en: 'No, the shape barely changes'
            },
            next: 'fluoro_polymers'
          }
        ]
      },
      ctfe: {
        type: 'result',
        title: {
          ru: 'Полихлортрифторэтилен (CTFE)',
          en: 'Polychlorotrifluoroethylene (CTFE)'
        },
        description: {
          ru: 'Не поддерживает горение и даёт вязкий расплав.',
          en: 'Does not sustain burning and yields a viscous melt.'
        },
        materials: [
          {
            name: {
              ru: 'CTFE',
              en: 'CTFE'
            },
            flame: {
              ru: 'Не горит',
              en: 'Does not burn'
            },
            odour: {
              ru: 'Отсутствует',
              en: 'None'
            },
            speed: {
              ru: 'Не горит',
              en: 'Does not burn'
            },
            other: {
              ru: 'При нагреве образует вязкие нити',
              en: 'Forms viscous strands when heated'
            }
          }
        ]
      },
      fluoro_polymers: {
        type: 'result',
        title: {
          ru: 'Фторполимеры (PTFE, FEP и др.)',
          en: 'Fluoropolymers (PTFE, FEP, etc.)'
        },
        description: {
          ru: 'Материал не поддерживает пламя и практически не плавится.',
          en: 'Does not sustain flame and barely melts.'
        },
        materials: [
          {
            name: {
              ru: 'PTFE / FEP / другие фторполимеры',
              en: 'PTFE / FEP / other fluoropolymers'
            },
            flame: {
              ru: 'Не горит',
              en: 'Does not burn'
            },
            odour: {
              ru: 'Отсутствует',
              en: 'None'
            },
            speed: {
              ru: 'Не горит',
              en: 'Does not burn'
            },
            other: {
              ru: 'Сохраняет форму, уголь не образуется',
              en: 'Keeps shape, little to no charring'
            }
          }
        ]
      }
      ,
      flame_present: {
        type: 'question',
        title: {
          ru: 'Есть пламя',
          en: 'Flame Present'
        },
        text: {
          ru: 'После удаления источника огня образец сам гаснет?',
          en: 'Does the sample self-extinguish once the flame is removed?'
        },
        description: {
          ru: 'Так мы отделяем самозатухающие материалы от тех, что продолжают гореть.',
          en: 'This separates self-extinguishing materials from those that keep burning.'
        },
        options: [
          {
            label: {
              ru: 'Нет, продолжает гореть',
              en: 'No, it keeps burning'
            },
            next: 'continues_drips'
          },
          {
            label: {
              ru: 'Да, самозатухает',
              en: 'Yes, it self-extinguishes'
            },
            next: 'self_ext_drips'
          }
        ]
      },
      continues_drips: {
        type: 'question',
        title: {
          ru: 'Продолжает гореть',
          en: 'Continues Burning'
        },
        text: {
          ru: 'Во время горения образуются капли расплава?',
          en: 'Does it form dripping melt while burning?'
        },
        options: [
          {
            label: {
              ru: 'Да, капли появляются',
              en: 'Yes, drips appear'
            },
            next: 'continues_drips_yes'
          },
          {
            label: {
              ru: 'Нет, капли не падают',
              en: 'No, no drips'
            },
            next: 'continues_drips_no'
          }
        ]
      },
      continues_drips_yes: {
        type: 'question',
        title: {
          ru: 'Капли при горении',
          en: 'Drips While Burning'
        },
        text: {
          ru: 'Как описать запах дыма?',
          en: 'How would you describe the smoke odour?'
        },
        options: [
          {
            label: {
              ru: 'Чистый запах стирола',
              en: 'Pure styrene smell'
            },
            next: 'ps'
          },
          {
            label: {
              ru: 'Стирол и резина',
              en: 'Styrene with rubber notes'
            },
            next: 'hips_san'
          },
          {
            label: {
              ru: 'Горький, резиновый запах',
              en: 'Bitter, rubbery smell'
            },
            next: 'abs'
          }
        ]
      },
      ps: {
        type: 'result',
        title: {
          ru: 'Полистирол (PS)',
          en: 'Polystyrene (PS)'
        },
        materials: [
          {
            name: {
              ru: 'Полистирол (PS)',
              en: 'Polystyrene (PS)'
            },
            flame: {
              ru: 'Жёлтое пламя',
              en: 'Yellow flame'
            },
            odour: {
              ru: 'Стирол',
              en: 'Styrene'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Густой дым с сажей',
              en: 'Dense smoke with soot'
            }
          }
        ]
      },
      hips_san: {
        type: 'result',
        title: {
          ru: 'Ударопрочный полистирол / SAN',
          en: 'High-impact PS / SAN'
        },
        description: {
          ru: 'Оба материала дают смесь запахов стирола и резины.',
          en: 'Both release a mix of styrene and rubber odours.'
        },
        materials: [
          {
            name: {
              ru: 'HIPS (ударопрочный полистирол)',
              en: 'HIPS (high-impact polystyrene)'
            },
            flame: {
              ru: 'Жёлтое пламя',
              en: 'Yellow flame'
            },
            odour: {
              ru: 'Стирол и резина',
              en: 'Styrene and rubber'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Чёрный дым с сажей',
              en: 'Black smoke with soot'
            }
          },
          {
            name: {
              ru: 'SAN (сополимер стирола и акрилонитрила)',
              en: 'SAN (styrene-acrylonitrile)'
            },
            flame: {
              ru: 'Жёлтое пламя',
              en: 'Yellow flame'
            },
            odour: {
              ru: 'Стирол и резина',
              en: 'Styrene and rubber'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Чёрный дым с сажей',
              en: 'Black smoke with soot'
            }
          }
        ]
      },
      abs: {
        type: 'result',
        title: {
          ru: 'АБС-пластик (ABS)',
          en: 'ABS Plastic'
        },
        materials: [
          {
            name: {
              ru: 'ABS',
              en: 'ABS'
            },
            flame: {
              ru: 'Жёлтое пламя',
              en: 'Yellow flame'
            },
            odour: {
              ru: 'Горький, резиновый',
              en: 'Bitter, rubbery'
            },
            speed: {
              ru: 'Медленно',
              en: 'Slow'
            },
            other: {
              ru: 'Чёрный дым с сажей',
              en: 'Black smoke with soot'
            }
          }
        ]
      },
      continues_drips_no: {
        type: 'question',
        title: {
          ru: 'Без капель',
          en: 'No Dripping'
        },
        text: {
          ru: 'Появляется ли дым при горении?',
          en: 'Is smoke produced while burning?'
        },
        options: [
          {
            label: {
              ru: 'Нет, дым почти отсутствует',
              en: 'No, almost no smoke'
            },
            next: 'no_smoke_speed'
          },
          {
            label: {
              ru: 'Да, заметен дым с сажей',
              en: 'Yes, noticeable sooty smoke'
            },
            next: 'smoke_odour'
          }
        ]
      },
      no_smoke_speed: {
        type: 'question',
        title: {
          ru: 'Без дыма',
          en: 'No Smoke'
        },
        text: {
          ru: 'Как быстро горит образец?',
          en: 'How quickly does the sample burn?'
        },
        options: [
          {
            label: {
              ru: 'Быстро',
              en: 'Fast'
            },
            next: 'pmma'
          },
          {
            label: {
              ru: 'Медленно',
              en: 'Slow'
            },
            next: 'pom'
          }
        ]
      },
      pmma: {
        type: 'result',
        title: {
          ru: 'Акрил (PMMA)',
          en: 'Acrylic (PMMA)'
        },
        materials: [
          {
            name: {
              ru: 'Полиметилметакрилат (PMMA)',
              en: 'Polymethyl methacrylate (PMMA)'
            },
            flame: {
              ru: 'Жёлтое пламя',
              en: 'Yellow flame'
            },
            odour: {
              ru: 'Метилированные спирты',
              en: 'Methylated spirits'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Практически без дыма',
              en: 'Almost no smoke'
            }
          }
        ]
      },
      pom: {
        type: 'result',
        title: {
          ru: 'Полиоксиметилен (POM)',
          en: 'Polyoxymethylene (POM)'
        },
        materials: [
          {
            name: {
              ru: 'POM (ацеталь)',
              en: 'POM (acetal)'
            },
            flame: {
              ru: 'Жёлтое пламя',
              en: 'Yellow flame'
            },
            odour: {
              ru: 'Формальдегид',
              en: 'Formaldehyde'
            },
            speed: {
              ru: 'Медленно',
              en: 'Slow'
            },
            other: {
              ru: 'Практически без дыма',
              en: 'Almost no smoke'
            }
          }
        ]
      },
      smoke_odour: {
        type: 'question',
        title: {
          ru: 'Дым с сажей',
          en: 'Sooty Smoke'
        },
        text: {
          ru: 'Какой запах ощущается?',
          en: 'What odour do you notice?'
        },
        options: [
          {
            label: {
              ru: 'Уксус или уксусный ангидрид',
              en: 'Vinegar or acetic anhydride'
            },
            next: 'cellulosics'
          },
          {
            label: {
              ru: 'Горящая резина',
              en: 'Burning rubber'
            },
            next: 'pet'
          }
        ]
      },
      cellulosics: {
        type: 'result',
        title: {
          ru: 'Целлулоидные пластики',
          en: 'Cellulosic Plastics'
        },
        materials: [
          {
            name: {
              ru: 'Целлулоид / другие целлюлозные пластики',
              en: 'Celluloid / other cellulosic plastics'
            },
            flame: {
              ru: 'Жёлтое пламя с искрами',
              en: 'Yellow flame with sparks'
            },
            odour: {
              ru: 'Уксус',
              en: 'Vinegar'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Лёгкий чёрный дым с сажей',
              en: 'Light black smoke with soot'
            }
          }
        ]
      },
      pet: {
        type: 'result',
        title: {
          ru: 'Полиэтилентерефталат (PET)',
          en: 'Polyethylene terephthalate (PET)'
        },
        materials: [
          {
            name: {
              ru: 'PET',
              en: 'PET'
            },
            flame: {
              ru: 'Жёлтое пламя с голубыми краями',
              en: 'Yellow flame with blue edges'
            },
            odour: {
              ru: 'Горящая резина',
              en: 'Burning rubber'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Чёрный дым с сажей',
              en: 'Black smoke with soot'
            }
          }
        ]
      }
      ,
      self_ext_drips: {
        type: 'question',
        title: {
          ru: 'Самозатухающие термопласты',
          en: 'Self-extinguishing Thermoplastics'
        },
        text: {
          ru: 'Во время горения образуются капли расплава?',
          en: 'Do dripping melts appear while burning?'
        },
        options: [
          {
            label: {
              ru: 'Да, появляются',
              en: 'Yes, there are drips'
            },
            next: 'self_ext_drip_smell'
          },
          {
            label: {
              ru: 'Нет, капель нет',
              en: 'No drips'
            },
            next: 'self_ext_no_drips_odour'
          }
        ]
      },
      self_ext_drip_smell: {
        type: 'question',
        title: {
          ru: 'Капли у самозатухающего материала',
          en: 'Dripping, Self-extinguishing'
        },
        text: {
          ru: 'Как пахнет дым?',
          en: 'How does the smoke smell?'
        },
        options: [
          {
            label: {
              ru: 'Прожжённые волосы или шерсть',
              en: 'Burnt hair or wool'
            },
            next: 'nylon'
          },
          {
            label: {
              ru: 'Сладковатый химический запах',
              en: 'Sweet chemical smell'
            },
            next: 'tpu'
          }
        ]
      },
      nylon: {
        type: 'result',
        title: {
          ru: 'Полиамид (нейлон)',
          en: 'Polyamide (Nylon)'
        },
        materials: [
          {
            name: {
              ru: 'Нейлон (PA)',
              en: 'Nylon (PA)'
            },
            flame: {
              ru: 'Жёлтое пламя с голубым кончиком',
              en: 'Yellow flame with blue tip'
            },
            odour: {
              ru: 'Прожжённые волосы',
              en: 'Burnt hair'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Образует капли расплава',
              en: 'Forms dripping melt'
            }
          }
        ]
      },
      tpu: {
        type: 'result',
        title: {
          ru: 'Термопластичные полиуретаны (TPU)',
          en: 'Thermoplastic Polyurethanes (TPU)'
        },
        materials: [
          {
            name: {
              ru: 'TPU',
              en: 'TPU'
            },
            flame: {
              ru: 'Жёлтое пламя',
              en: 'Yellow flame'
            },
            odour: {
              ru: 'Сладковатый химический запах',
              en: 'Sweet chemical smell'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Пузыри по фронту пламени',
              en: 'Bubbling at the flame front'
            }
          }
        ]
      },
      self_ext_no_drips_odour: {
        type: 'question',
        title: {
          ru: 'Без капель',
          en: 'No Drips'
        },
        text: {
          ru: 'Какой запах ощущается?',
          en: 'What odour do you notice?'
        },
        options: [
          {
            label: {
              ru: 'Запах серы',
              en: 'Sulphur smell'
            },
            next: 'polysulphone'
          },
          {
            label: {
              ru: 'Запах фенола',
              en: 'Phenolic smell'
            },
            next: 'phenol_branch'
          },
          {
            label: {
              ru: 'Едкий запах соляной кислоты',
              en: 'Sharp hydrochloric acid smell'
            },
            next: 'pvc'
          }
        ]
      },
      polysulphone: {
        type: 'result',
        title: {
          ru: 'Полисульфон (PSU)',
          en: 'Polysulfone (PSU)'
        },
        materials: [
          {
            name: {
              ru: 'Полисульфон (PSU)',
              en: 'Polysulfone (PSU)'
            },
            flame: {
              ru: 'Оранжевое пламя',
              en: 'Orange flame'
            },
            odour: {
              ru: 'Запах серы',
              en: 'Sulphur odour'
            },
            speed: {
              ru: 'Быстро',
              en: 'Fast'
            },
            other: {
              ru: 'Чёрный дым с сажей',
              en: 'Black smoke with soot'
            }
          }
        ]
      },
      phenol_branch: {
        type: 'question',
        title: {
          ru: 'Запах фенола',
          en: 'Phenolic Odour'
        },
        text: {
          ru: 'Обратите внимание на дополнительные признаки.',
          en: 'Look for additional signs.'
        },
        options: [
          {
            label: {
              ru: 'Чёрный дым с сажей',
              en: 'Black smoke with soot'
            },
            next: 'polycarbonate'
          },
          {
            label: {
              ru: 'Материал трудно воспламенить',
              en: 'Hard to ignite'
            },
            next: 'ppe'
          }
        ]
      },
      polycarbonate: {
        type: 'result',
        title: {
          ru: 'Поликарбонат (PC)',
          en: 'Polycarbonate (PC)'
        },
        materials: [
          {
            name: {
              ru: 'Поликарбонат (PC)',
              en: 'Polycarbonate (PC)'
            },
            flame: {
              ru: 'Оранжево-жёлтое пламя',
              en: 'Orange-yellow flame'
            },
            odour: {
              ru: 'Фенол',
              en: 'Phenol'
            },
            speed: {
              ru: 'Медленно',
              en: 'Slow'
            },
            other: {
              ru: 'Чёрный дым с сажей',
              en: 'Black smoke with soot'
            }
          }
        ]
      },
      ppe: {
        type: 'result',
        title: {
          ru: 'Полифениленовый эфир (PPE)',
          en: 'Polyphenylene Ether (PPE)'
        },
        materials: [
          {
            name: {
              ru: 'PPE',
              en: 'PPE'
            },
            flame: {
              ru: 'Оранжево-жёлтое пламя',
              en: 'Orange-yellow flame'
            },
            odour: {
              ru: 'Фенол',
              en: 'Phenol'
            },
            speed: {
              ru: 'Медленно',
              en: 'Slow'
            },
            other: {
              ru: 'Очень трудно воспламенить',
              en: 'Difficult to ignite'
            }
          }
        ]
      },
      pvc: {
        type: 'result',
        title: {
          ru: 'Поливинилхлорид (PVC)',
          en: 'Polyvinyl Chloride (PVC)'
        },
        materials: [
          {
            name: {
              ru: 'PVC',
              en: 'PVC'
            },
            flame: {
              ru: 'Жёлтое пламя с зеленоватыми краями',
              en: 'Yellow flame with green edges'
            },
            odour: {
              ru: 'Соляная кислота',
              en: 'Hydrochloric acid'
            },
            speed: {
              ru: 'Медленно',
              en: 'Slow'
            },
            other: {
              ru: 'Белый едкий дым, самозатухает',
              en: 'White acrid smoke, self-extinguishes'
            }
          }
        ]
      },
      thermoset_burn: {
        type: 'question',
        title: {
          ru: 'Термореактивный пластик',
          en: 'Thermosetting Plastic'
        },
        text: {
          ru: 'При сжигании небольшого образца он самозатухает или продолжает гореть?',
          en: 'When burning a small sample, does it self-extinguish or keep burning?'
        },
        options: [
          {
            label: {
              ru: 'Самозатухает',
              en: 'Self-extinguishes'
            },
            next: 'thermoset_self_smell'
          },
          {
            label: {
              ru: 'Продолжает гореть',
              en: 'Continues to burn'
            },
            next: 'thermoset_cont_smell'
          }
        ]
      },
      thermoset_self_smell: {
        type: 'question',
        title: {
          ru: 'Самозатухающие термореактивные пластики',
          en: 'Self-extinguishing Thermosets'
        },
        text: {
          ru: 'Какой запах ощущается?',
          en: 'What odour do you notice?'
        },
        options: [
          {
            label: {
              ru: 'Рыбный запах',
              en: 'Fish-like smell'
            },
            next: 'melamine'
          },
          {
            label: {
              ru: 'Фенол',
              en: 'Phenol'
            },
            next: 'phenol_formaldehyde'
          },
          {
            label: {
              ru: 'Формальдегид',
              en: 'Formaldehyde'
            },
            next: 'urea_formaldehyde'
          }
        ]
      },
      melamine: {
        type: 'result',
        title: {
          ru: 'Меламиноформальдегид',
          en: 'Melamine Formaldehyde'
        },
        materials: [
          {
            name: {
              ru: 'Melamine Formaldehyde',
              en: 'Melamine Formaldehyde'
            },
            flame: {
              ru: 'Жёлтое пламя с голубым кончиком',
              en: 'Yellow flame with blue tip'
            },
            odour: {
              ru: 'Рыбный',
              en: 'Fish-like'
            },
            speed: {
              ru: 'Самозатухает',
              en: 'Self-extinguishing'
            },
            other: {
              ru: 'Разбухает и трескается',
              en: 'Swells and cracks'
            }
          }
        ]
      },
      phenol_formaldehyde: {
        type: 'result',
        title: {
          ru: 'Фенолформальдегид',
          en: 'Phenol Formaldehyde'
        },
        materials: [
          {
            name: {
              ru: 'Phenol Formaldehyde',
              en: 'Phenol Formaldehyde'
            },
            flame: {
              ru: 'Жёлтое пламя',
              en: 'Yellow flame'
            },
            odour: {
              ru: 'Фенол',
              en: 'Phenol'
            },
            speed: {
              ru: 'Самозатухает',
              en: 'Self-extinguishing'
            },
            other: {
              ru: 'Может тлеть, поверхность темнеет',
              en: 'May smoulder; surface darkens'
            }
          }
        ]
      },
      urea_formaldehyde: {
        type: 'result',
        title: {
          ru: 'Мочевиноформальдегид',
          en: 'Urea Formaldehyde'
        },
        materials: [
          {
            name: {
              ru: 'Urea Formaldehyde',
              en: 'Urea Formaldehyde'
            },
            flame: {
              ru: 'Жёлтое пламя с зеленовато-голубой каймой',
              en: 'Yellow flame with green-blue edge'
            },
            odour: {
              ru: 'Формальдегид',
              en: 'Formaldehyde'
            },
            speed: {
              ru: 'Самозатухает',
              en: 'Self-extinguishing'
            },
            other: {
              ru: 'Разбухает и трескается',
              en: 'Swells and cracks'
            }
          }
        ]
      },
      thermoset_cont_smell: {
        type: 'question',
        title: {
          ru: 'Термореактивные, продолжающие гореть',
          en: 'Burning Thermosets'
        },
        text: {
          ru: 'Какой запах ощущается?',
          en: 'What odour do you notice?'
        },
        options: [
          {
            label: {
              ru: 'Рыбный',
              en: 'Fish-like'
            },
            next: 'unsaturated_polyester'
          },
          {
            label: {
              ru: 'Фенол',
              en: 'Phenol'
            },
            next: 'silicone'
          },
          {
            label: {
              ru: 'Резкий аминовый',
              en: 'Sharp amine odour'
            },
            next: 'epoxy'
          }
        ]
      },
      unsaturated_polyester: {
        type: 'result',
        title: {
          ru: 'Ненасыщенный полиэфир',
          en: 'Unsaturated Polyester'
        },
        materials: [
          {
            name: {
              ru: 'Unsaturated Polyester',
              en: 'Unsaturated Polyester'
            },
            flame: {
              ru: 'Жёлтое пламя с голубыми краями',
              en: 'Yellow flame with blue edges'
            },
            odour: {
              ru: 'Рыбный',
              en: 'Fish-like'
            },
            speed: {
              ru: 'Продолжает гореть',
              en: 'Continues to burn'
            },
            other: {
              ru: 'Чёрный дым с сажей',
              en: 'Black smoke with soot'
            }
          }
        ]
      },
      silicone: {
        type: 'result',
        title: {
          ru: 'Силикон',
          en: 'Silicone'
        },
        materials: [
          {
            name: {
              ru: 'Silicone',
              en: 'Silicone'
            },
            flame: {
              ru: 'Ярко-жёлтое пламя',
              en: 'Bright yellow flame'
            },
            odour: {
              ru: 'Фенол',
              en: 'Phenol'
            },
            speed: {
              ru: 'Продолжает гореть',
              en: 'Continues to burn'
            },
            other: {
              ru: 'Дым светлый, но горение длительное',
              en: 'Light smoke, prolonged burning'
            }
          }
        ]
      },
      epoxy: {
        type: 'result',
        title: {
          ru: 'Эпоксидная смола',
          en: 'Epoxy Resin'
        },
        materials: [
          {
            name: {
              ru: 'Epoxy',
              en: 'Epoxy'
            },
            flame: {
              ru: 'Жёлтое пламя',
              en: 'Yellow flame'
            },
            odour: {
              ru: 'Резкий амин',
              en: 'Pungent amine'
            },
            speed: {
              ru: 'Продолжает гореть',
              en: 'Continues to burn'
            },
            other: {
              ru: 'Чёрный дым',
              en: 'Black smoke'
            }
          }
        ]
      }
    };


const mapText = {
  progressLegend: { ru: 'Узлы на маршруте', en: 'Nodes on the route' },
  branchHint: { ru: 'Щёлкните, чтобы перестроить ветку с этого шага.', en: 'Click to rebuild the branch from this step.' },
  optionCurrent: { ru: 'Выберите направление', en: 'Choose a direction' },
  resultHint: { ru: 'Сравните свойства, чтобы подтвердить результат.', en: 'Review the properties to confirm the result.' },
  resultBadge: { ru: 'Результат', en: 'Result' },
  noResultYet: { ru: 'Продолжайте выбирать, чтобы увидеть перечень материалов.', en: 'Keep choosing to reveal candidate materials.' },
  sidePanelTitle: { ru: 'Маршрут', en: 'Route' },
  sidePanelEmpty: { ru: 'Ответы появятся после первого шага.', en: 'Your answers will appear after the first step.' },
  resultSelectPrompt: { ru: 'Выберите материал, чтобы раскрыть карточку свойств.', en: 'Select a material to reveal its properties.' },
  stepLabel: { ru: 'Шаг', en: 'Step' }
};


const supportedLanguages = ['ru', 'en'];
const CANVAS_SIZE = 4200;
const CANVAS_CENTER = CANVAS_SIZE / 2;
const NODE_DISTANCE = 420;
const VERTICAL_SPREAD = 0.85;

const headlineEl = document.getElementById('headline');
const leadEl = document.getElementById('lead');
const progressTrackEl = document.getElementById('progressTrack');
const progressLabelEl = document.getElementById('progressLabel');
const flowTrackEl = document.getElementById('flowTrack');
const mapSpaceEl = document.getElementById('mapSpace');
const mapPanEl = document.getElementById('mapPan');
const mapCanvasEl = document.getElementById('mapCanvas');
const mapLinksEl = document.getElementById('mapLinks');
const historySectionEl = document.getElementById('historySection');
const langButtons = document.querySelectorAll('.lang-button');
const langSwitcher = document.querySelector('.lang-switcher');
const classicLinkEl = document.getElementById('classicLink');
const sourceLinkEl = document.getElementById('sourceLink');
const backBtn = document.getElementById('backButton');
const resetBtn = document.getElementById('resetButton');

if (historySectionEl) {
  historySectionEl.setAttribute('role', 'log');
  historySectionEl.setAttribute('aria-live', 'polite');
  historySectionEl.setAttribute('aria-relevant', 'additions');
}

const browserLang = (navigator.language || navigator.userLanguage || 'ru').slice(0, 2).toLowerCase();
const defaultLang = supportedLanguages.includes(browserLang) ? browserLang : 'ru';

const state = {
  lang: defaultLang,
  steps: [{ nodeId: 'start', optionIndex: null }],
  selectedMaterial: null
};

const pan = { x: 0, y: 0 };
let scale = 1;
const SCALE_MIN = 0.45;
const SCALE_MAX = 2.75;
let pendingFocusIndex = 0;

const dragState = {
  active: false,
  pointerId: null,
  startX: 0,
  startY: 0,
  startPanX: 0,
  startPanY: 0
};

const touchState = {
  pointers: new Map(),
  previousDistance: null
};

langButtons.forEach((button) => {
  button.addEventListener('click', () => setLanguage(button.dataset.lang));
});

backBtn.addEventListener('click', () => goBack());
resetBtn.addEventListener('click', () => resetFlow());

if (mapSpaceEl) {
  mapSpaceEl.addEventListener('pointerdown', handlePointerDown);
  mapSpaceEl.addEventListener('pointermove', handlePointerMove);
  mapSpaceEl.addEventListener('pointerup', handlePointerEnd);
  mapSpaceEl.addEventListener('pointercancel', handlePointerEnd);
  mapSpaceEl.addEventListener('pointerleave', handlePointerEnd);
  mapSpaceEl.addEventListener('wheel', handleWheel, { passive: false });
}

applyTransform();
setLanguage(state.lang, true);
render();

function translate(value) {
  if (value === undefined || value === null) {
    return '';
  }
  if (typeof value === 'string') {
    return value;
  }
  if (typeof value === 'object') {
    if (value[state.lang]) {
      return value[state.lang];
    }
    if (value.ru) {
      return value.ru;
    }
    if (value.en) {
      return value.en;
    }
    for (const lang of supportedLanguages) {
      if (value[lang]) {
        return value[lang];
      }
    }
  }
  return '';
}

function setLanguage(lang, skipRender = false) {
  if (!supportedLanguages.includes(lang)) {
    lang = 'ru';
  }
  state.lang = lang;
  document.documentElement.lang = state.lang;
  document.title = translate(uiText.pageTitle);
  headlineEl.textContent = translate(uiText.heading);
  leadEl.textContent = translate(uiText.lead);
  if (classicLinkEl) {
    classicLinkEl.textContent = translate(uiText.classicLink);
  }
  if (sourceLinkEl) {
    sourceLinkEl.textContent = translate(uiText.sourceLink);
  }
  langSwitcher.setAttribute('aria-label', translate(uiText.languageSwitcher));
  updateLangButtons();
  updateActions();
  if (!skipRender) {
    render();
  }
}

function updateLangButtons() {
  langButtons.forEach((button) => {
    if (button.dataset.lang === state.lang) {
      button.classList.add('active');
      button.setAttribute('aria-pressed', 'true');
    } else {
      button.classList.remove('active');
      button.setAttribute('aria-pressed', 'false');
    }
  });
}

function render() {
  ensureSelectedMaterialValid();
  renderProgress();
  renderFlow();
  renderSidePanel();
  updateActions();
}

function ensureSelectedMaterialValid() {
  if (!state.selectedMaterial) {
    return;
  }
  const matchStep = state.steps.find((step) => step.nodeId === state.selectedMaterial.nodeId);
  if (!matchStep) {
    state.selectedMaterial = null;
    return;
  }
  const node = flow[matchStep.nodeId];
  if (!node || node.type !== 'result') {
    state.selectedMaterial = null;
    return;
  }
  if (!Array.isArray(node.materials) || !node.materials[state.selectedMaterial.materialIndex]) {
    state.selectedMaterial = null;
  }
}

function renderProgress() {
  progressTrackEl.innerHTML = '';
  state.steps.forEach((step, index) => {
    const node = flow[step.nodeId];
    if (!node) {
      return;
    }
    const dot = document.createElement('span');
    dot.className = 'progress-node';
    if (index === state.steps.length - 1) {
      if (node.type === 'result') {
        dot.classList.add('is-result');
      } else {
        dot.classList.add('is-current');
      }
    } else {
      dot.classList.add('is-complete');
    }
    dot.textContent = index + 1;
    dot.title = translate(node.title) || translate(mapText.stepLabel) + ' ' + (index + 1);
    progressTrackEl.appendChild(dot);
  });
  progressLabelEl.textContent = translate(mapText.progressLegend) + ': ' + state.steps.length;
}

function renderFlow() {
  flowTrackEl.innerHTML = '';
  mapLinksEl.innerHTML = '';
  const positions = computeStepPositions();

  state.steps.forEach((step, index) => {
    const node = flow[step.nodeId];
    if (!node) {
      return;
    }
    const article = document.createElement('article');
    article.className = 'flow-step';
    article.dataset.stepIndex = String(index);
    article.dataset.type = node.type;
    if (index === state.steps.length - 1) {
      article.dataset.status = node.type === 'result' ? 'result' : 'current';
    } else {
      article.dataset.status = 'complete';
    }

    const position = positions[index];
    const left = CANVAS_CENTER + position.x;
    const top = CANVAS_CENTER + position.y;
    article.style.left = left + 'px';
    article.style.top = top + 'px';

    const header = document.createElement('header');
    header.className = 'step-header';

    const badge = document.createElement('span');
    badge.className = 'step-index';
    badge.textContent = index + 1;
    header.appendChild(badge);

    const titleEl = document.createElement('h2');
    titleEl.className = 'step-title';
    titleEl.textContent = translate(node.title) || translate(mapText.stepLabel) + ' ' + (index + 1);
    header.appendChild(titleEl);

    article.appendChild(header);

    const body = document.createElement('div');
    body.className = 'step-body';
    article.appendChild(body);

    if (node.type === 'question') {
      const question = document.createElement('p');
      question.className = 'step-question';
      question.textContent = translate(node.text);
      body.appendChild(question);

      if (node.description) {
        const description = document.createElement('p');
        description.className = 'step-description';
        description.textContent = translate(node.description);
        body.appendChild(description);
      }

      const optionsWrap = document.createElement('div');
      optionsWrap.className = 'option-list';

      node.options.forEach((option, optionIndex) => {
        const optionBtn = document.createElement('button');
        optionBtn.type = 'button';
        optionBtn.className = 'option-node';
        optionBtn.dataset.stepIndex = String(index);
        optionBtn.dataset.optionIndex = String(optionIndex);

        const label = document.createElement('span');
        label.className = 'option-label';
        label.textContent = translate(option.label);
        optionBtn.appendChild(label);

        const noteText = translate(option.note);
        if (noteText) {
          const note = document.createElement('span');
          note.className = 'option-note';
          note.textContent = noteText;
          optionBtn.appendChild(note);
        }

        const selectedIndex = step.optionIndex;
        const isSelected = selectedIndex !== null && selectedIndex === optionIndex;
        const isCurrent = index === state.steps.length - 1;

        if (selectedIndex !== null && !isSelected) {
          optionBtn.classList.add('is-faded');
        }
        if (isSelected) {
          optionBtn.classList.add('is-selected');
        }
        optionBtn.title = isCurrent ? translate(mapText.optionCurrent) : translate(mapText.branchHint);

        optionBtn.addEventListener('click', () => handleOption(index, optionIndex));
        optionsWrap.appendChild(optionBtn);
      });

      body.appendChild(optionsWrap);
    } else if (node.type === 'result') {
      const badgeEl = document.createElement('span');
      badgeEl.className = 'result-badge';
      badgeEl.textContent = translate(mapText.resultBadge);
      body.appendChild(badgeEl);

      const descriptionText = translate(node.description);
      if (descriptionText) {
        const info = document.createElement('p');
        info.className = 'step-description';
        info.textContent = descriptionText;
        body.appendChild(info);
      }

      const materials = Array.isArray(node.materials) ? node.materials : [];
      const hasMaterials = materials.length > 0;
      const selection = hasMaterials && state.selectedMaterial && state.selectedMaterial.nodeId === step.nodeId
        ? materials[state.selectedMaterial.materialIndex]
        : null;

      if (hasMaterials) {
        const choicesWrap = document.createElement('div');
        choicesWrap.className = 'material-choice-list';

        materials.forEach((material, materialIndex) => {
          const choiceBtn = document.createElement('button');
          choiceBtn.type = 'button';
          choiceBtn.className = 'material-choice';
          const isActive = !!(state.selectedMaterial && state.selectedMaterial.nodeId === step.nodeId && state.selectedMaterial.materialIndex === materialIndex);
          if (isActive) {
            choiceBtn.classList.add('is-active');
          }
          choiceBtn.setAttribute('aria-pressed', isActive ? 'true' : 'false');

          const nameSpan = document.createElement('span');
          nameSpan.className = 'material-name';
          nameSpan.textContent = translate(material.name);
          choiceBtn.appendChild(nameSpan);

          choiceBtn.title = translate(mapText.resultSelectPrompt);

          choiceBtn.addEventListener('click', () => {
            const alreadySelected = state.selectedMaterial && state.selectedMaterial.nodeId === step.nodeId && state.selectedMaterial.materialIndex === materialIndex;
            state.selectedMaterial = alreadySelected ? null : { nodeId: step.nodeId, materialIndex };
            render();
          });

          choicesWrap.appendChild(choiceBtn);
        });

        body.appendChild(choicesWrap);
      }

      if (selection) {
        const detailCard = document.createElement('article');
        detailCard.className = 'material-card';

        const heading = document.createElement('h3');
        heading.textContent = translate(selection.name);
        detailCard.appendChild(heading);

        const props = document.createElement('div');
        props.className = 'material-props';

        const flame = document.createElement('p');
        flame.innerHTML = '<span>' + (state.lang === 'ru' ? 'Цвет пламени:' : 'Flame colour:') + '</span> ' + translate(selection.flame);
        props.appendChild(flame);

        const odour = document.createElement('p');
        odour.innerHTML = '<span>' + (state.lang === 'ru' ? 'Запах:' : 'Odour:') + '</span> ' + translate(selection.odour);
        props.appendChild(odour);

        const speed = document.createElement('p');
        speed.innerHTML = '<span>' + (state.lang === 'ru' ? 'Скорость горения:' : 'Burn rate:') + '</span> ' + translate(selection.speed);
        props.appendChild(speed);

        const other = document.createElement('p');
        other.innerHTML = '<span>' + (state.lang === 'ru' ? 'Другие признаки:' : 'Other traits:') + '</span> ' + translate(selection.other);
        props.appendChild(other);

        detailCard.appendChild(props);
        body.appendChild(detailCard);
      } else {
        const hint = document.createElement('p');
        hint.className = 'panel-placeholder';
        hint.textContent = translate(mapText.resultSelectPrompt);
        body.appendChild(hint);
      }
    }

    flowTrackEl.appendChild(article);
  });

  drawConnections();

  if (pendingFocusIndex !== null) {
    focusOnStep(pendingFocusIndex);
    pendingFocusIndex = null;
  }
}

function computeStepPositions() {
  const positions = [];
  state.steps.forEach((step, index) => {
    if (index === 0) {
      positions.push({ x: 0, y: 0 });
      return;
    }
    const prevStep = state.steps[index - 1];
    const prevPosition = positions[index - 1];
    const prevNode = flow[prevStep.nodeId];
    let optionIndex = prevStep.optionIndex || 0;
    if (prevStep.optionIndex === null) {
      optionIndex = 0;
    }
    let totalOptions = 1;
    if (prevNode && Array.isArray(prevNode.options) && prevNode.options.length) {
      totalOptions = prevNode.options.length;
    }
    const offset = computeOffset(optionIndex, totalOptions);
    positions.push({
      x: prevPosition.x + offset.x,
      y: prevPosition.y + offset.y
    });
  });
  return positions;
}

function computeOffset(optionIndex, totalOptions) {
  if (totalOptions <= 1) {
    return { x: NODE_DISTANCE, y: 0 };
  }
  const spread = Math.min(Math.PI * 0.85, Math.PI * 0.5 + totalOptions * 0.12);
  const ratio = totalOptions === 1 ? 0.5 : optionIndex / (totalOptions - 1);
  const angle = (ratio - 0.5) * spread;
  const x = Math.cos(angle) * NODE_DISTANCE;
  const y = Math.sin(angle) * NODE_DISTANCE * VERTICAL_SPREAD;
  return { x, y };
}

function drawConnections() {
  if (!mapLinksEl) {
    return;
  }
  mapLinksEl.innerHTML = '';
  for (let index = 1; index < state.steps.length; index += 1) {
    const prevEl = flowTrackEl.querySelector('[data-step-index="' + (index - 1) + '"]');
    const currentEl = flowTrackEl.querySelector('[data-step-index="' + index + '"]');
    if (!prevEl || !currentEl) {
      continue;
    }
    const x1 = prevEl.offsetLeft + prevEl.offsetWidth / 2;
    const y1 = prevEl.offsetTop + prevEl.offsetHeight / 2;
    const x2 = currentEl.offsetLeft + currentEl.offsetWidth / 2;
    const y2 = currentEl.offsetTop + currentEl.offsetHeight / 2;
    const dx = (x2 - x1) * 0.45;
    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
    const d = 'M ' + x1 + ' ' + y1 + ' C ' + (x1 + dx) + ' ' + y1 + ' ' + (x2 - dx) + ' ' + y2 + ' ' + x2 + ' ' + y2;
    path.setAttribute('d', d);
    path.setAttribute('fill', 'none');
    path.setAttribute('stroke', 'rgba(56, 189, 248, 0.42)');
    path.setAttribute('stroke-width', '3');
    path.setAttribute('stroke-linecap', 'round');
    mapLinksEl.appendChild(path);
  }
}

function renderSidePanel() {
  if (!historySectionEl) {
    return;
  }
  historySectionEl.innerHTML = '';

  const answeredSteps = state.steps.filter((step) => {
    const node = flow[step.nodeId];
    return node && node.type === 'question' && step.optionIndex !== null;
  });

  historySectionEl.setAttribute('data-empty', answeredSteps.length ? 'false' : 'true');

  let activeQuestionIndex = state.steps.length - 1;
  if (activeQuestionIndex >= 0) {
    const activeNode = flow[state.steps[activeQuestionIndex].nodeId];
    if (!activeNode || activeNode.type !== 'question' || state.steps[activeQuestionIndex].optionIndex === null) {
      for (let idx = state.steps.length - 1; idx >= 0; idx -= 1) {
        const candidateNode = flow[state.steps[idx].nodeId];
        if (candidateNode && candidateNode.type === 'question' && state.steps[idx].optionIndex !== null) {
          activeQuestionIndex = idx;
          break;
        }
      }
    }
  }

  const headerLine = document.createElement('div');
  headerLine.className = 'route-line route-header';
  headerLine.innerHTML = '<span class="prompt">#</span><span class="content">' + translate(mapText.sidePanelTitle) + '</span>';
  historySectionEl.appendChild(headerLine);

  if (!answeredSteps.length) {
    const placeholder = document.createElement('div');
    placeholder.className = 'route-line route-placeholder';
    placeholder.innerHTML = '<span class="prompt">$</span><span class="content">' + translate(mapText.sidePanelEmpty) + '</span>';
    historySectionEl.appendChild(placeholder);
  } else {
    state.steps.forEach((step, index) => {
      const node = flow[step.nodeId];
      if (!node || node.type !== 'question' || step.optionIndex === null) {
        return;
      }
      const option = node.options[step.optionIndex];
      if (!option) {
        return;
      }

      const titleText = translate(node.title);
      const questionText = translate(node.text);
      const questionLine = document.createElement('div');
      questionLine.className = 'route-line';
      const parts = [];
      if (titleText) {
        parts.push('[' + (index + 1) + '] ' + titleText + ':');
      }
      if (questionText) {
        parts.push(questionText);
      }
      if (!parts.length) {
        parts.push('[' + (index + 1) + '] ' + translate(mapText.stepLabel));
      }
      questionLine.innerHTML = '<span class="prompt">$</span><span class="content">' + parts.join(' ') + '</span>';
      if (index === activeQuestionIndex) {
        questionLine.classList.add('is-current');
      }
      historySectionEl.appendChild(questionLine);

      const answerLine = document.createElement('div');
      answerLine.className = 'route-line route-answer';
      answerLine.innerHTML = '<span class="prompt">↳</span><span class="content">' + translate(uiText.answerLabel) + ' ' + translate(option.label) + '</span>';
      if (index === activeQuestionIndex) {
        answerLine.classList.add('is-current');
      }
      historySectionEl.appendChild(answerLine);
    });
  }

  historySectionEl.scrollTop = historySectionEl.scrollHeight;

}

function updateActions() {
  backBtn.textContent = translate(uiText.back);
  resetBtn.textContent = translate(uiText.reset);
  const canGoBack = state.steps.length > 1;
  backBtn.disabled = !canGoBack;
  backBtn.setAttribute('aria-disabled', canGoBack ? 'false' : 'true');
}

function handleOption(stepIndex, optionIndex) {
  const step = state.steps[stepIndex];
  const node = flow[step.nodeId];
  if (!node || node.type !== 'question') {
    return;
  }

  const option = node.options[optionIndex];
  if (!option) {
    return;
  }

  step.optionIndex = optionIndex;
  state.steps = state.steps.slice(0, stepIndex + 1);
  state.selectedMaterial = null;

  if (!option.next || !flow[option.next]) {
    window.alert(translate(uiText.errorLoading));
    return;
  }

  state.steps.push({ nodeId: option.next, optionIndex: null });
  pendingFocusIndex = state.steps.length - 1;
  render();
}

function goBack() {
  if (state.steps.length <= 1) {
    return;
  }
  state.steps.pop();
  state.selectedMaterial = null;
  const current = state.steps[state.steps.length - 1];
  const node = flow[current.nodeId];
  if (node && node.type === 'question') {
    current.optionIndex = null;
  }
  pendingFocusIndex = state.steps.length - 1;
  render();
}

function resetFlow() {
  state.steps = [{ nodeId: 'start', optionIndex: null }];
  state.selectedMaterial = null;
  pendingFocusIndex = 0;
  centerMap();
  render();
}

function focusOnStep(index) {
  if (!flowTrackEl || !mapSpaceEl) {
    return;
  }
  const nodeEl = flowTrackEl.querySelector('[data-step-index="' + index + '"]');
  if (!nodeEl) {
    return;
  }
  const spaceRect = mapSpaceEl.getBoundingClientRect();
  const nodeRect = nodeEl.getBoundingClientRect();
  const offsetX = (spaceRect.left + spaceRect.width / 2) - (nodeRect.left + nodeRect.width / 2);
  const offsetY = (spaceRect.top + spaceRect.height / 2) - (nodeRect.top + nodeRect.height / 2);
  pan.x += offsetX;
  pan.y += offsetY;
  applyTransform();
}

function centerMap() {
  pan.x = 0;
  pan.y = 0;
  scale = 1;
  applyTransform();
}

function applyTransform() {
  if (mapPanEl) {
    mapPanEl.style.setProperty('--pan-x', pan.x + 'px');
    mapPanEl.style.setProperty('--pan-y', pan.y + 'px');
  }
  if (mapCanvasEl) {
    mapCanvasEl.style.setProperty('--map-scale', scale.toFixed(4));
  }
}

function handlePointerDown(event) {
  if (!mapSpaceEl || !mapPanEl) {
    return;
  }
  if (event.target.closest('button')) {
    return;
  }

  if (event.pointerType === 'touch') {
    touchState.pointers.set(event.pointerId, { x: event.clientX, y: event.clientY });
    if (touchState.pointers.size === 1) {
      touchState.previousDistance = null;
      startDrag(event, false);
    } else if (touchState.pointers.size === 2) {
      touchState.previousDistance = getTouchDistance();
      if (dragState.active) {
        endDrag(dragState.pointerId);
      }
    }
    event.preventDefault();
    return;
  }

  if (event.pointerType === 'mouse' && event.button !== 0) {
    return;
  }

  startDrag(event, true);
}

function handlePointerMove(event) {
  if (event.pointerType === 'touch') {
    if (touchState.pointers.has(event.pointerId)) {
      touchState.pointers.set(event.pointerId, { x: event.clientX, y: event.clientY });
    }
    if (touchState.pointers.size === 1 && !dragState.active) {
      touchState.previousDistance = null;
      startDrag(event, false);
    }
    if (touchState.pointers.size >= 2) {
      const distance = getTouchDistance();
      const center = getTouchCenter();
      if (touchState.previousDistance) {
        const factor = distance / touchState.previousDistance;
        applyZoomWithOrigin(factor, center.x, center.y);
      }
      touchState.previousDistance = distance;
      event.preventDefault();
      return;
    }
  }

  if (!dragState.active || event.pointerId !== dragState.pointerId) {
    return;
  }

  const deltaX = event.clientX - dragState.startX;
  const deltaY = event.clientY - dragState.startY;
  pan.x = dragState.startPanX + deltaX;
  pan.y = dragState.startPanY + deltaY;
  applyTransform();
  event.preventDefault();
}

function handlePointerEnd(event) {
  if (event.pointerType === 'touch') {
    touchState.pointers.delete(event.pointerId);
    if (touchState.pointers.size < 2) {
      touchState.previousDistance = null;
    }
  }

  if (dragState.active && dragState.pointerId === event.pointerId) {
    endDrag(event.pointerId);
  }
}

function handleWheel(event) {
  if (!mapPanEl) {
    return;
  }

  if (event.ctrlKey || event.metaKey) {
    const zoomFactor = Math.exp(-event.deltaY * 0.0015);
    applyZoomWithOrigin(zoomFactor, event.clientX, event.clientY);
    event.preventDefault();
    return;
  }

  const multiplier = event.deltaMode === 1 ? 16 : event.deltaMode === 2 ? 120 : 1;
  pan.x -= event.deltaX * multiplier;
  pan.y -= event.deltaY * multiplier;
  applyTransform();
  event.preventDefault();
}

function startDrag(event, allowCapture) {
  dragState.active = true;
  dragState.pointerId = event.pointerId;
  dragState.startX = event.clientX;
  dragState.startY = event.clientY;
  dragState.startPanX = pan.x;
  dragState.startPanY = pan.y;
  if (mapSpaceEl) {
    mapSpaceEl.classList.add('is-dragging');
    if (allowCapture && mapSpaceEl.setPointerCapture) {
      try {
        mapSpaceEl.setPointerCapture(event.pointerId);
      } catch (err) {}
    }
  }
  if (mapPanEl) {
    mapPanEl.classList.add('is-dragging');
  }
}

function endDrag(pointerId) {
  if (!dragState.active) {
    return;
  }
  dragState.active = false;
  dragState.pointerId = null;
  if (mapSpaceEl) {
    mapSpaceEl.classList.remove('is-dragging');
    if (pointerId !== undefined && mapSpaceEl.releasePointerCapture) {
      try {
        mapSpaceEl.releasePointerCapture(pointerId);
      } catch (err) {}
    }
  }
  if (mapPanEl) {
    mapPanEl.classList.remove('is-dragging');
  }
}

function getTouchPoints() {
  return Array.from(touchState.pointers.values());
}

function getTouchDistance() {
  const points = getTouchPoints();
  if (points.length < 2) {
    return 0;
  }
  const [a, b] = points;
  const dx = a.x - b.x;
  const dy = a.y - b.y;
  return Math.hypot(dx, dy);
}

function getTouchCenter() {
  const points = getTouchPoints();
  if (!points.length) {
    return { x: 0, y: 0 };
  }
  const sum = points.reduce((acc, point) => {
    acc.x += point.x;
    acc.y += point.y;
    return acc;
  }, { x: 0, y: 0 });
  return { x: sum.x / points.length, y: sum.y / points.length };
}

function applyZoomWithOrigin(factor, originX, originY) {
  if (!mapCanvasEl || !mapSpaceEl) {
    return;
  }
  const previousScale = scale;
  const targetScale = clampScale(previousScale * factor);
  if (!Number.isFinite(targetScale) || targetScale === previousScale) {
    scale = targetScale;
    applyTransform();
    return;
  }

  const rectBefore = mapCanvasEl.getBoundingClientRect();
  const relativeX = rectBefore.width ? (originX - rectBefore.left) / rectBefore.width : 0.5;
  const relativeY = rectBefore.height ? (originY - rectBefore.top) / rectBefore.height : 0.5;

  scale = targetScale;
  applyTransform();

  const rectAfter = mapCanvasEl.getBoundingClientRect();
  const desiredLeft = originX - relativeX * rectAfter.width;
  const desiredTop = originY - relativeY * rectAfter.height;

  pan.x += desiredLeft - rectAfter.left;
  pan.y += desiredTop - rectAfter.top;
  applyTransform();
}

function clampScale(value) {
  return Math.min(SCALE_MAX, Math.max(SCALE_MIN, value));
}

  </script>
</body>
</html>
