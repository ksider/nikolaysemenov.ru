<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Интерактивная идентификация пластиков</title>
  <link rel="stylesheet" href="styles.css">
  
</head>
<body>
  <main class="container">
    <div class="header">
      <h1 id="headline"></h1>
      <div class="lang-switcher" role="group" aria-label="Language selector">
        <button type="button" class="lang-button" data-lang="ru">Русский</button>
        <button type="button" class="lang-button" data-lang="en">English</button>
      </div>
    </div>
    <p id="lead" class="lead"></p>


    <section id="content" class="card"></section>
    <section id="history" class="card history-card"></section>    
    
    <div class="top-links">
      <!-- <a class="top-link" id="mapLink" href="./map.html">Перейти к интерактивной карте</a> -->
      <a class="top-link" id="classicSourceLink" href="https://www.stanmech.com/articles/plastics-identification-flow-chart#:~:text=Plastics%20Identification%20Flow%20Chart%20-%20Articles,Roofing" target="_blank" rel="noopener noreferrer">Source</a>
    </div>
  </main>

  <script src="flow-data.js"></script>
  <script>
    const supportedLanguages = ['ru', 'en'];

    const uiText = {
      pageTitle: {
        ru: 'Интерактивная идентификация пластиков',
        en: 'Interactive Plastic Identification'
      },
      heading: {
        ru: 'Интерактивная идентификация пластиков',
        en: 'Interactive Plastic Identification'
      },
      lead: {
        ru: 'Следуйте шагам блок-схемы: отвечайте на вопросы и сравнивайте наблюдения, чтобы сузить круг подходящих материалов. В любой момент можно вернуться на шаг назад или начать заново.',
        en: 'Follow the flowchart: answer the questions and compare your observations to narrow down possible plastics. You can step back or restart at any moment.'
      },
      historyHeading: {
        ru: 'Пройденный путь',
        en: 'Path Taken'
      },
      historyPlaceholder: {
        ru: 'Ответы появятся после выбора первого варианта.',
        en: 'Your answers will appear after you make the first choice.'
      },
      back: {
        ru: 'Назад',
        en: 'Back'
      },
      reset: {
        ru: 'Начать заново',
        en: 'Start over'
      },
      answerLabel: {
        ru: 'Ответ:',
        en: 'Answer:'
      },
      errorLoading: {
        ru: 'Не удалось загрузить следующий шаг.',
        en: 'Failed to load the next step.'
      },
      languageSwitcher: {
        ru: 'Переключатель языка',
        en: 'Language selector'
      },
      mapLink: {
        ru: 'Открыть бэкап с картой',
        en: 'Open map backup'
      },
      sourceLink: {
        ru: 'Источник',
        en: 'Source'
      },
      infoHeading: {
        ru: 'Дополнительные сведения',
        en: 'Additional details'
      },
      infoSource: {
        ru: 'Источник',
        en: 'Source'
      },
      infoHint: {
        ru: 'Можно подключить файл polymer-notes.json с описанием полимеров.',
        en: 'You can supply a polymer-notes.json file with descriptions.'
      },
      mediaToggleShow: {
        ru: 'Показать иллюстрации',
        en: 'Show illustrations'
      },
      mediaToggleHide: {
        ru: 'Скрыть иллюстрации',
        en: 'Hide illustrations'
      },
      mediaPlaceholder: {
        ru: 'Здесь можно добавить фото или видео шага.',
        en: 'Add a photo or video for this step here.'
      },
      mediaDefaultCaption: {
        ru: 'Визуальная подсказка к шагу.',
        en: 'Visual reference for this step.'
      }
    };

    const flow = window.flowData || {};
    const contentEl = document.getElementById('content');
    const historyEl = document.getElementById('history');
    const headlineEl = document.getElementById('headline');
    const leadEl = document.getElementById('lead');
    const mapLinkEl = document.getElementById('mapLink');
    const sourceLinkEl = document.getElementById('classicSourceLink');
    const langSwitcher = document.querySelector('.lang-switcher');
    const langButtons = document.querySelectorAll('.lang-button');

    const MATERIAL_INFO_URL = 'polymer-notes.json';
    let materialInfo = {};
    let materialInfoLoaded = false;

    const browserLang = (navigator.language || navigator.userLanguage || 'en').slice(0, 2).toLowerCase();
    const defaultLang = supportedLanguages.includes(browserLang) ? browserLang : 'en';

    let currentLang = defaultLang;
    let currentNodeId = 'start';
    let historyStack = [];
    let showMedia = true;

    loadMaterialInfo();

    langButtons.forEach((button) => {
      button.addEventListener('click', () => setLanguage(button.dataset.lang));
    });

    setLanguage(currentLang, true);
    render();

    async function loadMaterialInfo() {
      try {
        const response = await fetch(MATERIAL_INFO_URL, { cache: 'no-store' });
        if (!response.ok) {
          materialInfoLoaded = true;
          return;
        }
        const data = await response.json();
        if (data && typeof data === 'object') {
          materialInfo = data;
        }
        materialInfoLoaded = true;
        render();
      } catch {
        materialInfoLoaded = true;
      }
    }

    function translate(value) {
      if (value === undefined || value === null) {
        return '';
      }
      if (typeof value === 'string') {
        return value;
      }
      if (typeof value === 'object') {
        if (value[currentLang]) {
          return value[currentLang];
        }
        if (value.ru) {
          return value.ru;
        }
        if (value.en) {
          return value.en;
        }
        const fallbackLang = supportedLanguages.find((lang) => value[lang]);
        if (fallbackLang) {
          return value[fallbackLang];
        }
      }
      return '';
    }

    function setLanguage(lang, skipRender = false) {
      if (!supportedLanguages.includes(lang)) {
        lang = 'en';
      }
      currentLang = lang;
      document.documentElement.lang = currentLang;
      document.title = translate(uiText.pageTitle);
      headlineEl.textContent = translate(uiText.heading);
      leadEl.textContent = translate(uiText.lead);
      if (mapLinkEl) {
        mapLinkEl.textContent = translate(uiText.mapLink);
      }
      if (sourceLinkEl) {
        sourceLinkEl.textContent = translate(uiText.sourceLink);
      }
      langSwitcher.setAttribute('aria-label', translate(uiText.languageSwitcher));
      renderLanguageSwitcher();
      if (!skipRender) {
        render();
      }
    }

    function renderLanguageSwitcher() {
      langButtons.forEach((button) => {
        if (button.dataset.lang === currentLang) {
          button.classList.add('active');
          button.setAttribute('aria-pressed', 'true');
        } else {
          button.classList.remove('active');
          button.setAttribute('aria-pressed', 'false');
        }
      });
    }

    function render() {
      renderHistory();
      const node = flow[currentNodeId];
      contentEl.innerHTML = '';

      if (!node) {
        const error = document.createElement('p');
        error.textContent = translate(uiText.errorLoading);
        contentEl.appendChild(error);
        renderActions();
        return;
      }

      if (node.type === 'question') {
        renderQuestion(node);
      } else if (node.type === 'result') {
        renderResult(node);
      }

      renderActions();
    }

    function renderQuestion(node) {
      const layout = document.createElement('div');
      layout.className = 'question-layout';
      const shouldRenderMedia = showMedia && !!node.media;
      if (shouldRenderMedia) {
        layout.classList.add('has-media');
      }

      const column = document.createElement('div');
      column.className = 'question-column';

      const titleText = translate(node.title);
      if (titleText) {
        const heading = document.createElement('h2');
        heading.textContent = titleText;
        column.appendChild(heading);
      }

      const text = document.createElement('p');
      text.className = 'question-text';
      text.textContent = translate(node.text);
      column.appendChild(text);

      const descriptionText = translate(node.description);
      if (descriptionText) {
        const context = document.createElement('p');
        context.className = 'question-context';
        context.textContent = descriptionText;
        column.appendChild(context);
      }

      const optionsWrap = document.createElement('div');
      optionsWrap.className = 'options';

      node.options.forEach((option, index) => {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'option-button';

        const labelSpan = document.createElement('span');
        labelSpan.className = 'option-label';
        labelSpan.textContent = translate(option.label);
        button.appendChild(labelSpan);

        const noteText = translate(option.note);
        if (noteText) {
          const noteSpan = document.createElement('span');
          noteSpan.className = 'option-note';
          noteSpan.textContent = noteText;
          button.appendChild(noteSpan);
        }

        button.addEventListener('click', () => handleOption(index));
        optionsWrap.appendChild(button);
      });

      column.appendChild(optionsWrap);
      layout.appendChild(column);

      if (shouldRenderMedia) {
        const mediaFigure = buildStepMedia(node.media, translate(node.text));
        if (mediaFigure) {
          mediaFigure.classList.add('question-media');
          layout.appendChild(mediaFigure);
        }
      }

      contentEl.appendChild(layout);
    }

    function renderResult(node) {
      const layout = document.createElement('div');
      layout.className = 'question-layout';
      const shouldRenderMedia = showMedia && !!node.media;
      if (shouldRenderMedia) {
        layout.classList.add('has-media');
      }

      const column = document.createElement('div');
      column.className = 'question-column';

      const titleText = translate(node.title);
      if (titleText) {
        const heading = document.createElement('h2');
        heading.textContent = titleText;
        column.appendChild(heading);
      }

      const descriptionText = translate(node.description);
      if (descriptionText) {
        const description = document.createElement('p');
        description.className = 'question-context';
        description.textContent = descriptionText;
        column.appendChild(description);
      }

      const list = document.createElement('div');
      list.className = 'material-grid';

      node.materials.forEach((material) => {
        const card = document.createElement('article');
        card.className = 'material-card';

        const title = document.createElement('h3');
        title.textContent = translate(material.name);
        card.appendChild(title);

        const flame = document.createElement('p');
        flame.className = 'material-prop';
        flame.innerHTML = '<span>' + (currentLang === 'ru' ? 'Цвет пламени:' : 'Flame colour:') + '</span> ' + translate(material.flame);
        card.appendChild(flame);

        const odour = document.createElement('p');
        odour.className = 'material-prop';
        odour.innerHTML = '<span>' + (currentLang === 'ru' ? 'Запах:' : 'Odour:') + '</span> ' + translate(material.odour);
        card.appendChild(odour);

        const speed = document.createElement('p');
        speed.className = 'material-prop';
        speed.innerHTML = '<span>' + (currentLang === 'ru' ? 'Скорость горения:' : 'Burn rate:') + '</span> ' + translate(material.speed);
        card.appendChild(speed);

        const other = document.createElement('p');
        other.className = 'material-prop';
        other.innerHTML = '<span>' + (currentLang === 'ru' ? 'Другие признаки:' : 'Other traits:') + '</span> ' + translate(material.other);
        card.appendChild(other);

        list.appendChild(card);
      });

      column.appendChild(list);

      const infoBlock = renderMaterialInfo(currentNodeId, node);
      if (infoBlock) {
        column.appendChild(infoBlock);
      }

      layout.appendChild(column);

      if (shouldRenderMedia) {
        const mediaFigure = buildStepMedia(node.media, translate(node.title));
        if (mediaFigure) {
          mediaFigure.classList.add('question-media');
          layout.appendChild(mediaFigure);
        }
      }

      contentEl.appendChild(layout);
    }

    function buildStepMedia(mediaConfig, fallbackAlt = '') {
      if (!mediaConfig) {
        return null;
      }

      const figure = document.createElement('figure');
      figure.className = 'step-media';

      const frame = document.createElement('div');
      frame.className = 'step-media-frame';
      let hasMedia = false;
      const config = mediaConfig || null;
      const aspectRatio = resolveAspectRatio(config);
      if (aspectRatio) {
        frame.style.aspectRatio = aspectRatio.text;
        if (aspectRatio.isPortrait) {
          frame.classList.add('is-portrait');
        }
      }

      if (config && config.type === 'video' && (config.src || (Array.isArray(config.sources) && config.sources.length))) {
        const video = document.createElement('video');
        video.preload = 'metadata';
        video.playsInline = true;
        video.controls = config.controls === false ? false : true;
        if (config.poster) {
          video.poster = config.poster;
        }
        if (Array.isArray(config.sources) && config.sources.length) {
          config.sources.forEach((source) => {
            if (!source || !source.src) {
              return;
            }
            const sourceEl = document.createElement('source');
            sourceEl.src = source.src;
            if (source.type) {
              sourceEl.type = source.type;
            }
            video.appendChild(sourceEl);
          });
        } else if (config.src) {
          video.src = config.src;
        }
        const titleText = translate(config.title) || fallbackAlt || translate(uiText.mediaDefaultCaption);
        if (titleText) {
          video.title = titleText;
        }
        frame.appendChild(video);
        hasMedia = true;
      } else if (config && config.type === 'image' && config.src) {
        const img = document.createElement('img');
        img.src = config.src;
        const altText = translate(config.alt) || fallbackAlt || translate(uiText.mediaDefaultCaption);
        if (altText) {
          img.alt = altText;
        }
        frame.appendChild(img);
        hasMedia = true;
      } else if (
        config &&
        (config.type === 'youtube' || config.type === 'embed') &&
        (config.videoId || config.src)
      ) {
        const iframe = document.createElement('iframe');
        const baseSrc = config.src || ('https://www.youtube.com/embed/' + encodeURIComponent(config.videoId));
        const params = new URLSearchParams();
        if (config.params && typeof config.params === 'object') {
          Object.entries(config.params).forEach(([key, value]) => {
            if (value === undefined || value === null) {
              return;
            }
            params.set(key, String(value));
          });
        }
        if (config.type === 'youtube') {
          if (!params.has('rel')) params.set('rel', '0');
          if (!params.has('modestbranding')) params.set('modestbranding', '1');
          if (!params.has('showinfo')) params.set('showinfo', '0');
          if (!params.has('playsinline')) params.set('playsinline', '1');
        }
        const paramString = params.toString();
        iframe.src = baseSrc + (paramString ? (baseSrc.includes('?') ? '&' : '?') + paramString : '');
        const titleText = translate(config.title) || fallbackAlt || translate(uiText.mediaDefaultCaption);
        if (titleText) {
          iframe.title = titleText;
        }
        iframe.allow =
          'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share';
        iframe.allowFullscreen = true;
        iframe.referrerPolicy = 'strict-origin-when-cross-origin';
        frame.appendChild(iframe);
        hasMedia = true;
      }

      if (!hasMedia) {
        return null;
      }

      figure.appendChild(frame);

      const captionSource = hasMedia && config ? config.caption : null;
      const captionText = translate(captionSource) || translate(uiText.mediaDefaultCaption);
      if (captionText) {
        const caption = document.createElement('figcaption');
        caption.className = 'step-media-caption';
        caption.textContent = captionText;
        figure.appendChild(caption);
      }

      return figure;
    }

    function resolveAspectRatio(config) {
      if (!config) {
        return null;
      }
      if (config.aspectRatio !== undefined) {
        const parsed = parseAspectRatioValue(config.aspectRatio);
        if (parsed) {
          return parsed;
        }
      }
      if (config.orientation) {
        switch (config.orientation) {
          case 'portrait':
            return parseAspectRatioValue('9/16');
          case 'square':
            return parseAspectRatioValue(1);
          case 'landscape':
            return parseAspectRatioValue('16/9');
          default:
            break;
        }
      }
      return null;
    }

    function parseAspectRatioValue(raw) {
      if (raw === undefined || raw === null) {
        return null;
      }
      let value = null;
      let text = null;
      if (typeof raw === 'number') {
        if (Number.isFinite(raw) && raw > 0) {
          value = raw;
        }
      } else if (typeof raw === 'string') {
        const cleaned = raw.trim();
        const parts = cleaned.split('/');
        if (parts.length === 2) {
          const width = parseFloat(parts[0]);
          const height = parseFloat(parts[1]);
          if (Number.isFinite(width) && Number.isFinite(height) && width > 0 && height > 0) {
            value = width / height;
            text = width + ' / ' + height;
          }
        }
        if (!value) {
          const parsed = parseFloat(cleaned);
          if (Number.isFinite(parsed) && parsed > 0) {
            value = parsed;
          }
        }
      }
      if (!value) {
        return null;
      }
      if (!text) {
        text = Number.isInteger(value) ? String(value) : value.toFixed(4).replace(/0+$/, '').replace(/\.$/, '');
      }
      return {
        value,
        text,
        isPortrait: value < 1
      };
    }

    function getLocalizedInfo(infoNode) {
      if (!infoNode || typeof infoNode !== 'object') {
        return null;
      }
      if (infoNode[currentLang]) {
        return infoNode[currentLang];
      }
      if (infoNode.ru) {
        return infoNode.ru;
      }
      if (infoNode.en) {
        return infoNode.en;
      }
      const fallbackLang = supportedLanguages.find((lang) => infoNode[lang]);
      if (fallbackLang) {
        return infoNode[fallbackLang];
      }
      return null;
    }

    function renderMaterialInfo(nodeId, node) {
      if (!materialInfoLoaded) {
        return null;
      }
      const infoData = getLocalizedInfo(materialInfo[nodeId]);
      if (!infoData) {
        const hint = document.createElement('p');
        hint.className = 'info-hint';
        hint.textContent = translate(uiText.infoHint);
        return hint;
      }

      const wrap = document.createElement('article');
      wrap.className = 'info-card';

      const heading = document.createElement('h4');
      heading.textContent = translate(uiText.infoHeading);
      wrap.appendChild(heading);

      if (infoData.title) {
        const sub = document.createElement('p');
        sub.className = 'material-prop';
        sub.textContent = infoData.title;
        wrap.appendChild(sub);
      }

      if (Array.isArray(infoData.body)) {
        infoData.body.forEach((text) => {
          if (!text) {
            return;
          }
          const p = document.createElement('p');
          p.textContent = text;
          wrap.appendChild(p);
        });
      } else if (infoData.body) {
        const p = document.createElement('p');
        p.textContent = infoData.body;
        wrap.appendChild(p);
      }

      if (infoData.source) {
        const source = document.createElement('p');
        source.innerHTML = '<strong>' + translate(uiText.infoSource) + ':</strong> ';
        const link = document.createElement('a');
        link.href = infoData.source;
        link.target = '_blank';
        link.rel = 'noopener noreferrer';
        link.textContent = infoData.sourceLabel || infoData.source;
        source.appendChild(link);
        wrap.appendChild(source);
      }

      return wrap;
    }

    function renderActions() {
      const actions = document.createElement('div');
      actions.className = 'actions';

      const mediaToggle = document.createElement('button');
      mediaToggle.type = 'button';
      mediaToggle.id = 'mediaToggleButton';
      mediaToggle.className = 'ghost-button';
      const mediaLabel = translate(showMedia ? uiText.mediaToggleHide : uiText.mediaToggleShow);
      mediaToggle.textContent = mediaLabel;
      mediaToggle.setAttribute('aria-pressed', showMedia ? 'true' : 'false');
      mediaToggle.addEventListener('click', () => {
        showMedia = !showMedia;
        render();
      });
      actions.appendChild(mediaToggle);

      if (historyStack.length) {
        const backBtn = document.createElement('button');
        backBtn.type = 'button';
        backBtn.className = 'ghost-button';
        backBtn.textContent = translate(uiText.back);
        backBtn.addEventListener('click', goBack);
        actions.appendChild(backBtn);
      }

      const resetBtn = document.createElement('button');
      resetBtn.type = 'button';
      resetBtn.className = 'ghost-button';
      resetBtn.textContent = translate(uiText.reset);
      resetBtn.addEventListener('click', resetFlow);
      actions.appendChild(resetBtn);

      contentEl.appendChild(actions);
    }

    function handleOption(optionIndex) {
      const node = flow[currentNodeId];
      const option = node.options[optionIndex];

      historyStack.push({
        nodeId: currentNodeId,
        optionIndex
      });

      currentNodeId = option.next;
      render();
    }

    function goBack() {
      const last = historyStack.pop();
      if (last) {
        currentNodeId = last.nodeId;
      } else {
        currentNodeId = 'start';
      }
      render();
    }

    function resetFlow() {
      currentNodeId = 'start';
      historyStack = [];
      render();
    }

    function renderHistory() {
      historyEl.innerHTML = '';

      const heading = document.createElement('h2');
      heading.textContent = translate(uiText.historyHeading);
      historyEl.appendChild(heading);

      if (!historyStack.length) {
        const placeholder = document.createElement('p');
        placeholder.className = 'history-placeholder';
        placeholder.textContent = translate(uiText.historyPlaceholder);
        historyEl.appendChild(placeholder);
        return;
      }

      const list = document.createElement('ol');
      list.className = 'history-list';

      historyStack.forEach((item) => {
        const questionNode = flow[item.nodeId];
        if (!questionNode) {
          return;
        }
        const option = questionNode.options[item.optionIndex];
        const li = document.createElement('li');
        li.className = 'history-item';

        const questionLine = document.createElement('span');
        const titleText = translate(questionNode.title);
        const questionText = translate(questionNode.text);
        questionLine.textContent = titleText ? titleText + ': ' + questionText : questionText;
        li.appendChild(questionLine);

        const answerLine = document.createElement('strong');
        answerLine.textContent = translate(uiText.answerLabel) + ' ' + translate(option.label);
        li.appendChild(answerLine);

        list.appendChild(li);
      });

      historyEl.appendChild(list);
    }
  </script>

      <!-- Yandex.Metrika counter -->   
<script type="text/javascript" > (function(m,e,t,r,i,k,a){m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)}; m[i].l=1*new Date();k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)}) (window, document, "script", "https://mc.yandex.ru/metrika/tag.js", "ym"); ym(16681432, "init", { clickmap:true, trackLinks:true, accurateTrackBounce:true, webvisor:true }); </script> <noscript><div><img src="https://mc.yandex.ru/watch/16681432" style="position:absolute; left:-9999px;" alt="" /></div></noscript> 
<!-- /Yandex.Metrika counter -->
</body>
</html>
